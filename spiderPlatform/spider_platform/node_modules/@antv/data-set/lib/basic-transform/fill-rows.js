"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var util_1 = require("@antv/util");
var partition_1 = require("../util/partition");
var helper_1 = require("../helper");
function arrayDifference(arr1, arr2) {
    var shadow = tslib_1.__spread(arr1); // shadow copy
    arr2.forEach(function (item) {
        var index = shadow.indexOf(item);
        if (index > -1) {
            shadow.splice(index, 1);
        }
    });
    return shadow;
}
function fillRows(rows, options) {
    var opts = helper_1.mergeOptions(options, { fillBy: 'group' });
    var cloneRows = util_1.deepMix([], rows);
    var groupBy = opts.groupBy, orderBy = opts.orderBy;
    var groups = partition_1.partition(cloneRows, groupBy, orderBy);
    var maxLength = 0;
    var referenceGroup = [];
    util_1.forIn(groups, function (group) {
        if (group.length > maxLength) {
            maxLength = group.length;
            referenceGroup = group;
        }
    });
    var referenceOrderByKeys = [];
    var referenceRowByOrderByKey = {};
    referenceGroup.forEach(function (row) {
        var key = orderBy.map(function (col) { return row[col]; }).join('-');
        referenceOrderByKeys.push(key);
        referenceRowByOrderByKey[key] = row;
    });
    if (opts.fillBy === 'order') {
        var first_1 = referenceGroup[0];
        var allOrderByKeys_1 = [];
        var rowByOrderByKey_1 = {};
        cloneRows.forEach(function (row) {
            var key = orderBy.map(function (col) { return row[col]; }).join('-');
            if (allOrderByKeys_1.indexOf(key) === -1) {
                allOrderByKeys_1.push(key);
                rowByOrderByKey_1[key] = row;
            }
        });
        var _missingOrderByKeys = arrayDifference(allOrderByKeys_1, referenceOrderByKeys);
        _missingOrderByKeys.forEach(function (key) {
            var row = {};
            groupBy.forEach(function (col) {
                row[col] = first_1[col];
            });
            orderBy.forEach(function (col) {
                row[col] = rowByOrderByKey_1[key][col];
            });
            cloneRows.push(row);
            referenceGroup.push(row);
            referenceOrderByKeys.push(key);
            referenceRowByOrderByKey[key] = row;
        });
        maxLength = referenceGroup.length;
    }
    util_1.forIn(groups, function (group) {
        if (group !== referenceGroup && group.length < maxLength) {
            var first_2 = group[0];
            // missing orderBy keys
            var orderByKeys_1 = [];
            group.forEach(function (row) {
                orderByKeys_1.push(orderBy.map(function (col) { return row[col]; }).join('-'));
            });
            var missingOrderByKeys = arrayDifference(referenceOrderByKeys, orderByKeys_1);
            missingOrderByKeys.some(function (key, i) {
                if (i >= maxLength - group.length) {
                    // group length overflow
                    return true;
                }
                var referenceRow = referenceRowByOrderByKey[key];
                var row = {};
                groupBy.forEach(function (col) {
                    row[col] = first_2[col];
                });
                orderBy.forEach(function (col) {
                    row[col] = referenceRow[col];
                });
                cloneRows.push(row);
                return false;
            });
        }
    });
    return cloneRows;
}
exports.fillRows = fillRows;
