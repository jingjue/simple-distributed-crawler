"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/*
 * kernel density estimation
 */
var util_1 = require("@antv/util");
var get_series_values_1 = tslib_1.__importDefault(require("../util/get-series-values"));
var kernel_1 = tslib_1.__importDefault(require("../util/kernel"));
var bw = tslib_1.__importStar(require("../util/bandwidth"));
var partition_1 = require("../util/partition");
var simple_statistics_1 = require("simple-statistics");
var helper_1 = require("../helper");
var DEFAULT_OPTIONS = {
    minSize: 0.01,
    as: ['key', 'y', 'size'],
    // fields: [ 'y1', 'y2' ], // required, one or more fields
    // extent: [], // extent to execute regression function, default: [ [ min(x), max(x) ], [ min(y), max(y) ] ]
    method: 'gaussian',
    bandwidth: 'nrd',
};
var KERNEL_METHODS = util_1.keys(kernel_1.default);
function kde(rows, options) {
    var opts = helper_1.mergeOptions(options, DEFAULT_OPTIONS);
    var fields = options.fields, groupBy = options.groupBy, bandwidth = options.bandwidth, method = options.method;
    if (!fields || !Array.isArray(fields) || fields.length < 1) {
        throw new TypeError('invalid fields: must be an array of at least 1 strings!');
    }
    if (!opts.as || !Array.isArray(opts.as) || opts.as.length !== 3) {
        throw new TypeError('invalid as: must be an array of 3 strings!');
    }
    var methodFunc;
    if (typeof method === 'string') {
        if (KERNEL_METHODS.indexOf(method) === -1) {
            throw new TypeError("invalid method: " + method + ". Must be one of " + KERNEL_METHODS.join(', '));
        }
        methodFunc = kernel_1.default[method];
    }
    if (util_1.isFunction(method)) {
        methodFunc = method;
    }
    var extent = opts.extent;
    if (!extent || !Array.isArray(extent) || extent.length === 0) {
        var rangeArr_1 = [];
        fields.forEach(function (field) {
            rangeArr_1.push.apply(rangeArr_1, tslib_1.__spread(helper_1.range(rows.map(function (item) { return item[field]; }))));
        });
        extent = helper_1.range(rangeArr_1);
    }
    var step = 0;
    if (typeof bandwidth === 'string' && bw[bandwidth]) {
        step = bw[bandwidth](rows.map(function (item) { return item[fields[0]]; }));
    }
    else if (util_1.isFunction(bandwidth)) {
        step = bandwidth(rows.map(function (item) { return item[fields[0]]; }));
    }
    else if (!util_1.isNumber(bandwidth) || bandwidth <= 0) {
        step = bw.nrd(rows.map(function (item) { return item[fields[0]]; }));
    }
    var seriesValues = get_series_values_1.default(extent, step);
    var result = [];
    var groups = partition_1.partition(rows, groupBy);
    util_1.forIn(groups, function (group) {
        var probalityDensityFunctionByField = {};
        util_1.each(fields, function (field) {
            var row = util_1.pick(group[0], groupBy);
            probalityDensityFunctionByField[field] = simple_statistics_1.kernelDensityEstimation(group.map(function (item) { return item[field]; }), methodFunc, step);
            var _a = tslib_1.__read(opts.as, 3), key = _a[0], y = _a[1], size = _a[2];
            row[key] = field;
            row[y] = [];
            row[size] = [];
            util_1.each(seriesValues, function (yValue) {
                var sizeValue = probalityDensityFunctionByField[field](yValue);
                if (sizeValue >= opts.minSize) {
                    row[y].push(yValue);
                    row[size].push(sizeValue);
                }
            });
            result.push(row);
        });
    });
    return result;
}
exports.kde = kde;
