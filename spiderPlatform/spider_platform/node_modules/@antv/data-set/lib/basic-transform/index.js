"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var util_1 = require("@antv/util");
var helper_1 = require("../helper");
var simple_statistics_1 = require("simple-statistics");
tslib_1.__exportStar(require("./aggregate"), exports);
// bin
// collect
// countpattern
tslib_1.__exportStar(require("./cross"), exports);
/**
 * 过滤
 * @param rows - 数据
 * @param options - 配置
 * @public
 */
function filter(rows, options) {
    if (options && options.callback)
        return rows.filter(options.callback);
    return rows.filter(function (row) { return !!row; });
}
exports.filter = filter;
tslib_1.__exportStar(require("./flatten"), exports);
tslib_1.__exportStar(require("./fold"), exports);
// formula => map
// identifier
tslib_1.__exportStar(require("./kde"), exports);
tslib_1.__exportStar(require("./impute"), exports);
// joinaggregate
// loess
tslib_1.__exportStar(require("./lookup"), exports);
tslib_1.__exportStar(require("./pivot"), exports);
tslib_1.__exportStar(require("./project"), exports);
// quantile
tslib_1.__exportStar(require("./regression"), exports);
/**
 * 随机提取样本
 * @param rows - 数据
 * @param options - 参数
 * @public
 */
function sample(rows, options) {
    var size = helper_1.mergeOptions(options || {}, { size: 1000 }).size;
    return simple_statistics_1.sample(rows, size, Math.random);
}
exports.sample = sample;
// sequence
// timeunit
// window
tslib_1.__exportStar(require("./percent"), exports);
tslib_1.__exportStar(require("./fill-rows"), exports);
/**
 * 提取指定列
 * @param rows - 数据
 * @param options - 参数
 * @public
 */
function pick(rows, options) {
    return rows.map(function (row) { return util_1.pick(row, options.fields); });
}
exports.pick = pick;
function rename(rows, options) {
    if (!options || Object.keys(options.map).length === 0)
        return rows;
    return rows.map(function (row) {
        var e_1, _a;
        var reslut = tslib_1.__assign({}, row);
        try {
            for (var _b = tslib_1.__values(Object.entries(options.map)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var _d = tslib_1.__read(_c.value, 2), key = _d[0], value = _d[1];
                reslut[value] = row[key];
                delete reslut[key];
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return reslut;
    });
}
exports.rename = rename;
function map(rows, options) {
    return rows.map(options.callback);
}
exports.map = map;
function reverse(rows) {
    return rows.reverse();
}
exports.reverse = reverse;
function sort(rows, options) {
    return rows.sort(options.callback);
}
exports.sort = sort;
function sortBy(rows, options) {
    var fields = options.fields;
    // TODO: throw in case field.length is 0;
    var sortedRows = util_1.sortBy(rows, fields);
    var order = options.order;
    if (order && ['ASC', 'DESC'].indexOf(order) === -1) {
        throw new TypeError("Invalid order: " + order + " must be one of " + ['ASC', 'DESC'].join(', '));
    }
    else if (order === 'DESC') {
        sortedRows.reverse();
    }
    return sortedRows;
}
exports.sortBy = sortBy;
function subset(rows, options) {
    if (options === void 0) { options = {}; }
    var startIndex = options.startRowIndex || 0;
    var endIndex = options.endRowIndex || rows.length;
    var result = rows.slice(startIndex, endIndex + 1);
    if (helper_1.checkArray(options.fields)) {
        return result.map(function (row) { return util_1.pick(row, options.fields); });
    }
    return result;
}
exports.subset = subset;
